<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Manual MSE TS-player (fetch .html as TS)</title>
  <style>
    body{font-family:system-ui;margin:20px;background:#111;color:#eee}
    input{width:70%}
    button{padding:6px 10px;margin-left:8px}
    video{width:100%;max-width:900px;margin-top:16px;background:#000}
    pre{white-space:pre-wrap;color:#9ad}
  </style>
</head>
<body>
  <h2>Manual MSE test — read remote .html as TS</h2>
  <p>Paste a single segment URL (page-0.html) below and press Play.</p>

  <input id="url" placeholder="https://.../page-0.html" />
  <button id="playBtn">Play</button>
  <button id="stopBtn">Stop</button>
  <p id="log">idle</p>

  <video id="video" controls></video>
  <pre id="debug"></pre>

<script>
const video = document.getElementById('video');
const urlInput = document.getElementById('url');
const playBtn = document.getElementById('playBtn');
const stopBtn = document.getElementById('stopBtn');
const logEl = document.getElementById('log');
const debug = document.getElementById('debug');

function log(s){
  logEl.textContent = s;
  debug.textContent = (new Date()).toISOString() + "  " + s + "\n" + debug.textContent;
  console.log(s);
}

let mediaSource = null;
let sb = null;
let abortController = null;

playBtn.addEventListener('click', async () => {
  const segUrl = urlInput.value.trim();
  if (!segUrl) return alert('Paste the segment URL first');

  // reset
  stopPlayback();

  log('Starting — creating MediaSource');
  mediaSource = new MediaSource();
  video.src = URL.createObjectURL(mediaSource);

  // NOTE: codec string must match your TS stream. If it fails, try removing codecs param:
  // 'video/mp2t' OR exact codecs 'video/mp2t; codecs="avc1.42E01E, mp4a.40.2"'
  const MIME = 'video/mp2t; codecs="avc1.42E01E, mp4a.40.2"';

  mediaSource.addEventListener('sourceopen', async () => {
    log('MediaSource opened — adding SourceBuffer (' + MIME + ')');
    try {
      sb = mediaSource.addSourceBuffer(MIME);
    } catch (e) {
      log('addSourceBuffer failed. Trying without codecs...');
      try {
        sb = mediaSource.addSourceBuffer('video/mp2t');
      } catch (e2) {
        log('addSourceBuffer failed (no supported mime). See console for details.');
        console.error(e, e2);
        return;
      }
    }

    // small queue to ensure we append sequentially
    const appendQueue = [];
    let appending = false;

    function enqueueAppend(buf) {
      appendQueue.push(buf);
      if (!appending) processQueue();
    }

    function processQueue() {
      if (!appendQueue.length) { appending = false; return; }
      appending = true;
      const buf = appendQueue.shift();
      try {
        sb.appendBuffer(buf);
      } catch (err) {
        log('appendBuffer error: ' + err);
        console.error(err);
        appending = false;
        return;
      }
      const onEnd = () => {
        sb.removeEventListener('updateend', onEnd);
        // optional: prune buffer to keep memory low
        try {
          if (sb.buffered && sb.buffered.length) {
            // keep only last 30s; adjust if needed
            const end = sb.buffered.end(sb.buffered.length - 1);
            const removeUntil = Math.max(0, end - 30);
            if (removeUntil > 0) {
              try { sb.remove(0, removeUntil); } catch(e){/**/}
            }
          }
        } catch(e){}
        processQueue();
      };
      sb.addEventListener('updateend', onEnd, { once: true });
    }

    // Fetch & append the single segment
    try {
      log('Fetching segment: ' + segUrl);
      abortController = new AbortController();
      const resp = await fetch(segUrl, { signal: abortController.signal, credentials: 'omit' });
      if (!resp.ok) {
        log('Fetch failed: ' + resp.status + ' ' + resp.statusText);
        return;
      }
      const buf = await resp.arrayBuffer();
      log('Fetched ' + buf.byteLength + ' bytes — appending to SourceBuffer');
      enqueueAppend(new Uint8Array(buf));
      // start playback once some data appended
      video.play().catch(e => { console.warn('play() failed', e); });
    } catch (err) {
      if (err.name === 'AbortError') log('Fetch aborted');
      else {
        log('Fetch error: ' + err);
        console.error(err);
        // CORS likely: show hint
        if (err instanceof TypeError) {
          log('Fetch blocked — likely CORS. Use a proxy or run this page from same origin.');
        }
      }
    }
  });

  mediaSource.addEventListener('error', e => {
    log('MediaSource error: ' + e);
  });

});

stopBtn.addEventListener('click', stopPlayback);

function stopPlayback(){
  if (abortController) { try{ abortController.abort(); }catch(e){} }
  try { if (sb) { sb.abort(); } } catch(e){}
  try { if (mediaSource && mediaSource.readyState === 'open') mediaSource.endOfStream(); } catch(e){}
  try { video.pause(); video.removeAttribute('src'); video.load(); } catch(e){}
  mediaSource = null; sb = null; abortController = null;
  log('stopped/reset');
}

// Small helper: example URL prefill
urlInput.value = 'https://galaxypathways.xyz/content/e19783f02cff4a720881491fd7f0c6fb/6a909f4727881a3469bd52fa9b42122c/page-0.html';
</script>
</body>
</html>
